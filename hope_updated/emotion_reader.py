"""
Utility module to read and analyze facial emotion data for conversational AI integration.
This reads the emotion data generated by face.py and provides it to the agent.
"""

import pandas as pd
import os
from datetime import datetime
import time

class EmotionReader:
    def __init__(self, data_dir="emotion_data"):
        """Initialize the emotion reader with the data directory."""
        self.data_dir = data_dir
        self.excel_filename = f"{data_dir}/emotions_data.xlsx"
        self.summary_filename = f"{data_dir}/emotions_summary.xlsx"
        self.voice_segments_filename = f"{data_dir}/voice_segments.xlsx"
    
    def get_recent_emotion(self, seconds=10):
        """
        Get the dominant emotion from the last N seconds.
        
        Args:
            seconds: Number of seconds to look back (default: 10)
            
        Returns:
            dict: Contains dominant emotion, confidence, and emotion breakdown
        """
        try:
            if not os.path.exists(self.excel_filename):
                return {
                    "status": "no_data",
                    "message": "No emotion data available yet",
                    "dominant_emotion": "neutral"
                }
            
            # Read the emotion data
            df = pd.read_excel(self.excel_filename)
            
            if df.empty:
                return {
                    "status": "no_data",
                    "message": "Emotion data file is empty",
                    "dominant_emotion": "neutral"
                }
            
            # Filter for recent data
            current_time = time.time()
            cutoff_time = current_time - seconds
            recent_df = df[df['timestamp'] >= cutoff_time]
            
            if recent_df.empty:
                # If no recent data, use the most recent available
                recent_df = df.tail(5)
            
            # Calculate average scores for each emotion
            all_emotions = ['angry', 'disgust', 'fear', 'happy', 'sad', 'surprise', 'neutral']
            emotion_scores = {}
            
            for emotion in all_emotions:
                col_name = f"{emotion}_score"
                if col_name in recent_df.columns:
                    emotion_scores[emotion] = recent_df[col_name].mean()
            
            # Apply the same weighting as in face.py
            weighted_scores = emotion_scores.copy()
            boost_factors = {
                "sad": 2.0,
                "happy": 2.2,
                "surprise": 1.5,
                "angry": 1.2,
                "disgust": 1.5,
                "fear": 1.2,
                "neutral": 1.0
            }
            
            for emotion in weighted_scores:
                weighted_scores[emotion] *= boost_factors.get(emotion, 1.0)
            
            # Find dominant emotion
            dominant_emotion = max(weighted_scores, key=weighted_scores.get)
            confidence = weighted_scores[dominant_emotion]
            
            return {
                "status": "success",
                "dominant_emotion": dominant_emotion,
                "confidence": confidence,
                "emotion_scores": emotion_scores,
                "weighted_scores": weighted_scores,
                "frame_count": len(recent_df),
                "time_window_seconds": seconds
            }
            
        except Exception as e:
            return {
                "status": "error",
                "message": f"Error reading emotion data: {str(e)}",
                "dominant_emotion": "neutral"
            }
    
    def get_emotion_trend(self, seconds=30):
        """
        Get emotion trend over a longer period to detect changes.
        
        Args:
            seconds: Time window to analyze (default: 30)
            
        Returns:
            dict: Emotion trends and changes over time
        """
        try:
            if not os.path.exists(self.excel_filename):
                return {"status": "no_data", "trend": "stable"}
            
            df = pd.read_excel(self.excel_filename)
            if df.empty:
                return {"status": "no_data", "trend": "stable"}
            
            current_time = time.time()
            cutoff_time = current_time - seconds
            recent_df = df[df['timestamp'] >= cutoff_time].sort_values('timestamp')
            
            if len(recent_df) < 10:
                return {"status": "insufficient_data", "trend": "stable"}
            
            # Split into first and second half to detect trend
            mid_point = len(recent_df) // 2
            first_half = recent_df.iloc[:mid_point]
            second_half = recent_df.iloc[mid_point:]
            
            # Get dominant emotions for each half
            all_emotions = ['angry', 'disgust', 'fear', 'happy', 'sad', 'surprise', 'neutral']
            
            def get_dominant(df_part):
                scores = {}
                for emotion in all_emotions:
                    col = f"{emotion}_score"
                    if col in df_part.columns:
                        scores[emotion] = df_part[col].mean()
                return max(scores, key=scores.get) if scores else "neutral"
            
            first_dominant = get_dominant(first_half)
            second_dominant = get_dominant(second_half)
            
            # Detect trend
            if first_dominant != second_dominant:
                trend = f"changing from {first_dominant} to {second_dominant}"
            else:
                trend = f"stable at {second_dominant}"
            
            return {
                "status": "success",
                "trend": trend,
                "first_half_emotion": first_dominant,
                "second_half_emotion": second_dominant,
                "is_changing": first_dominant != second_dominant
            }
            
        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
                "trend": "stable"
            }
    
    def get_emotional_context_for_agent(self):
        """
        Get a formatted emotional context string suitable for the agent's prompt.
        This is the main method to call for agent integration.
        
        Returns:
            str: Formatted emotional context description
        """
        recent = self.get_recent_emotion(seconds=10)
        trend = self.get_emotion_trend(seconds=30)
        
        if recent["status"] != "success":
            return "No recent facial emotion data available. Proceed with neutral emotional tone."
        
        dominant = recent["dominant_emotion"]
        confidence = recent.get("confidence", 0)
        
        # Create context string
        context_parts = [
            f"CURRENT FACIAL EMOTION: {dominant.upper()} (confidence: {confidence:.1f})"
        ]
        
        # Add intensity description
        if confidence > 70:
            context_parts.append("The emotion is STRONGLY detected.")
        elif confidence > 40:
            context_parts.append("The emotion is moderately detected.")
        else:
            context_parts.append("The emotion is subtly detected.")
        
        # Add trend information
        if trend["status"] == "success" and trend.get("is_changing"):
            context_parts.append(f"EMOTIONAL TREND: {trend['trend']}")
        
        # Add specific guidance based on emotion
        emotion_guidance = {
            "happy": "The user appears happy. Be upbeat and engaging while maintaining supportive presence.",
            "sad": "The user appears sad. Show extra empathy, validate their feelings, and offer gentle support.",
            "angry": "The user appears angry or frustrated. Acknowledge their feelings calmly, avoid being dismissive.",
            "fear": "The user appears anxious or fearful. Be reassuring, calm, and supportive.",
            "surprise": "The user appears surprised. Match their energy appropriately and be responsive.",
            "disgust": "The user appears uncomfortable. Be understanding and non-judgmental.",
            "neutral": "The user appears calm. Maintain a friendly, supportive conversational tone."
        }
        
        guidance = emotion_guidance.get(dominant, "Maintain empathetic and supportive tone.")
        context_parts.append(f"GUIDANCE: {guidance}")
        
        return "\n".join(context_parts)


# Convenience function for quick access
def get_current_emotion_context(data_dir="emotion_data"):
    """
    Quick function to get current emotional context.
    Use this in your agent's instruction or as a tool.
    """
    reader = EmotionReader(data_dir)
    return reader.get_emotional_context_for_agent()